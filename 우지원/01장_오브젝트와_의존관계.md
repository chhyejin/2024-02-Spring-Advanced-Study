# 1장 오브젝트와 의존관계
1. [초난감 DAO](#11-초난감-dao)
2. [DAO의 분리](#12-dao의-분리)
3. [DAO의 확장](#13-dao의-확장)
4. [제어의 역전(IoC)](#14-제어의-역전ioc)
5. [스프링의 IoC](#15-스프링의-ioc)
6. [싱글톤 레지스트리와 오브젝트 스코프](#16-싱글톤-레지스트리와-오브젝트-스코프)
7. [의존관계 주입(DI)](#17-의존관계-주입di)
8. [XML을 이용한 설정](#18-xml을-이용한-설정)


<br>

## 1.1 초난감 DAO

### 🍃 DAO (Data Access Object)
DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트


- UserDAO 코드

```java
    public class UserDao {
    	public void add(User user) throws ... {
    		Class.forName("com.mysql.jdbc.Driver");
    		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
    		
    		PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
    		ps.setString(1, user.getId());
			...
    	
    		ps.executeUpdate();
    	
    		ps.close();
    		c.close();
    	}
    
    	public User get(String id) throws ... {
    		...
    	}
    }
```
이 코드는 관심사의 분리가 이루어지지 않은 초난감 DAO코드다!
<br><br>
## 1.2 DAO의 분리

### 🍃 관심사의 분리
- 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 **미래의 변화**를 어떻게 대비할 것인가? 
    -  변화의 폭을 최소한으로 줄여주는 것이 가장 좋은 대책이고, **분리와 확장**을 고려한 설계를 통해 대비할 수 있음!

- 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어나므로 한 가지 관심이 한 군데에 집중되게 하도록 설계해야한다.

- **관심이 같은 것끼리는 모으고, 관심이 다른 것은 가능한 한 따로 떨어져서 영향을 주지 않도록 분리**하는 것이 바로 **관심사의 분리**!
<br><br>
### 🍃 커넥션 만들기의 추출
중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만든다.

> **리팩토링 refactoring**<br/>
	기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.

<br><br>
### 🍃 DB 커넥션 만들기의 독립

#### 상속을 통한 확장

1. getConnection()의 구현 코드를 제거하여 추상 메소드로 만든다.
2. 각각의 고객은 UserDao를 상속한 서브클래스를 생성하여 getConnection()을 원하는 방식대로 구현하면 된다.

> **디자인 패턴**<br/>
	소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 객체지향적 설계 원칙을 이용해 문제를 해결한다.

> **템플릿 메소드 패턴**<br/>
	상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.

> **팩토리 메소드 패턴**<br/>
	서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼 클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

<br><br>
## 1.3 DAO의 확장
#### 💥 상속의 문제점  

1) UserDao가 다른 목적을 위해 상속을 사용하고 있다면?
    * 여전히 상속관계는 두 가지 다른 관심사에 대자바는 클래스의 다중상속을 허용하지 않음
    * 다른 목적으로 UserDao에 상속을 적용하기 힘듦

2) 상속을 통한 상하위 클래스의 관계는 생각보다 밀접함.
    * 여전히 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용함 (서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있음)

3) 확장된 기능의 코드를 다른 DAO클래스에 적용할 수 없음.
    * 다른 DAO 클래스들에도 getConnection의 구현 코드가 중복해서 나타나는 심각한 문제가 발생함

<br><br>
### 🍃 클래스의 분리
상속관계도 아닌 완전히 독립적인 클래스로 만든다!

```java
public class UserDao {
	private SimpleConnectionMaker simpleConnectionMaker;

	public UserDao() {
		simpleConnectionMaker = new SimpleConnectionMaker();
	}

	public void add(User user) throws ... {
		Connection c = simpleConnectionMaker.makeNewConnection();
	}

	...
}
```
```java
public class SimpleConnectionMaker {
	public Connection makeNewConnection() throws ... {
		Class.forName("com.mysql.jdbc.Driver");
		return DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
	}
}
```

하지만 다른 문제 발생!  


UserDao의 코드가 SimpleConnectionMaker 라는 특정 클래스에 종속되어있기 때문에 DB커넥션 생성 기능을 변경하고 싶으면 UserDao 코드를 수정해야한다
<br>
### 🍃 인터페이스의 도입
추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이고, 자바가 추상화를 위해 제공하는 가장 유용한 도구는 **인터페이스**이다.
<br>

### 🍃 관계 설정 책임의 분리
인터페이스를 도입해서 UserDao와 ConnectionMaker라는 두개의 관심을 분리했지만, UserDao에는 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 코드가 남아있다.
* UserDao의 클라이언트가 ConnectionMaker 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성하고 생성자를 통해 오브젝트를 전달한다.
<br><br>
### 🍃 원칙과 패턴
#### 개방 폐쇄 원칙
* OCP :  Open-Closed Principle
* 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

#### 객체 지향 설계 원칙(SOLID)
객체지향의 특징을 잘 살릴 수 있는 설계의 특징을 말하며 로버트 마틴이 정리한 5가지 객체지향 설계 원칙이다!

* SRP : 단일 책임 원칙
* OCP : 개방 폐쇄 원칙
* LSP : 리스코프 치환 원칙
* ISP : 인터페이스 분리 원칙
* DIP : 의존관계 역전 원칙

<br>

#### 높은 응집도와 낮은 결합도
개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 SW개발의 고전적인 원리로도 설명이 가능함

* 높은 응집도
  * 하나의 모듈, 클래스가 하나의 책임 똔ㄴ 관심사에만 집중되어 있다.
  * 하나의 공통 관심사는 한 클래스에!

* 낮은 결합도
  
  * 하나의 공통 관심사는 한 클래스에!
<br><br>
#### 전략 패턴
자신의 기능 맥락(context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
<br><br>
## 1.4 제어의 역전(IoC)

### 🍃 오브젝트 팩토리
UserDaoTest는 
1) 기존에 UserDao가 직접 담당하던 기능인 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능
2) UserDao의 기능이 잘 동작하는지 테스트하는 기능

즉, 기능들을 분리해야한다!

#### 팩토리
팩토리 클래스는 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 가진다.

팩토리 역할을 맡을 클래스를 DaoFactory라 하자. DaoFactory를 분리하면서 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는데 의미가 존재한다!

<br>

### 🍃 제어권의 이전을 통한 제어관계 역전
**제어의 역전**이라는 것은 간단히 말하면 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 모든 제어권한을 자신이 아닌 다른 대상에게 위임하기 떄문이다. 

**프레임워크**도 제어의 역전 개념이 적용된 대표적인 기술이다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다!
<br><br>
## 1.5 스프링의 IoC
#### 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점
* 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
* 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
* 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
<br><br>
### 🍃 스프링 IoC의 용어 정리
> **빈 bean**<br/>
	빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻으로, 관리되는 오브젝트 (managed object) 라고 부르기도 한다. 스프링 애플리케이션의 모든 오브젝트 중, 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다.

> **빈 팩토리 bean factory**<br/>
	스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.

> **애플리케이션 컨텍스트 application context**<br/>
	빈 팩토리를 확장한 IoC 컨테이너이다. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. ApplicationContext는 BeanFactory를 상속한다.

> **설정정보/설정 메타정보 configuration metadata**<br/>
	스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다.

> **컨테이너container 또는 IoC 컨테이너**<br/>
	IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다. 

<br><br>
## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> **오브젝트의 동일성과 동등성**<br/>
    두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트라고 말하는 것과, 동일한 정보를 담고 있는 (equivalent) 오브젝트라고 말하는 것은 차이가 있다.  
    동일성(identity) 비교는 == 연산자로 함.  
    동등성 (equality) 비교는 equals() 메소드로 함.  

### 🍃 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 함!

**왜 스프링은 싱글톤으로 빈을 만드는 것일까?**  
대규모의 엔터프라이즈 서버환경에서 스프링이 대부분 사용되고, 이런 시스템에서 오브젝트 생성으로 인한 부하를 줄이기 위해서 싱글톤의 사용이 권장된다.

하지만 싱글톤 패턴의 한계로 안티패턴이라고 부르는 사람도 있다고 한다.

#### 싱글톤 패턴의 한계
- private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤은 테스트하기가 힘들다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

#### 싱글톤 레지스트리 Singletone registry
스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는데, 이것이 싱글톤 레지스트리이다.
싱글톤이 멀티스테드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 Stateless방식으로 만들어져야 한다.
<br><br>
### 🍃 스프링 빈의 스코프
빈이 생성되고, 존재하고, 적용되는 범위를 빈의 스코프 scope라고 한다.


- 스프링 빈의 기본 스코프는 싱글톤
컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.


* 프로토타입 스코프: 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 생성함.
* 요청 스코프 : HTTP 요청이 있을 때마다 생성됨.
* 세션 스코프 : 웹의 세션과 스코프가 유사.
<br><br>
## 1.7 의존관계 주입(DI)

### 🍃 의존관계 검색과 주입
스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색(dependency Lookup)이라고 불리는 것도 있다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.

- 다음은 의존관계 검색을 사용하는 UserDao 생성자이다.

```java
public UserDao() {

    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);

    this.connectionMaker = context.getBean("connectionMaker",  ConnectionMaker.class);

}
```

getBean() 이라는 메소드는 의존관계 검색에 사용된다. UserDao는 애플리케이션 컨텍스트를 사용해서 의존관계 검색방식으로 ConnectionMaker 오브젝트를 가져오게 만들 수도 있다.
<br><br>
### 🍃 메소드를 이용한 의존관계 주입
- 수정자 메소드를 이용한 주입
- 일반 메소드를 이용한 주입
<br><br>
## 1.8 XML을 이용한 설정
\<beans> 를 루트 엘리먼트로 사용하고, 이 안에 여러개의 \<bean> 을 정의할 수 있음.


하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 3가지임
- 빈의 이름
- 빈의 클래스
- 빈의 의존 오브젝트
<br><br>
### 🍃 XML 설정

|           | 자바 코드 설정정보          | XML 설정정보              |
|-----------|--------------------------|--------------------------  |
| 빈 설정파일| `@Configuration`         |       `<beans>`            |
| 빈의 이름  | `@Bean methodName()`     | `<bean id="methodName"`    |
| 빈의 클래스| `return new BeanClass();`| `class="a.b.c.BeanClass">` |


---
## 🔍질문
❓ 개방폐쇄원칙에 대해 설명해주세요.

=> 확장에는 열려있고 변경에는 닫혀있어야 한다라는 의미로 정의할 수 있다. 새로운 요구사항이나 기능을 추가적으로 구현할 때 확장을 통해 구현하지만 확장에 따른 수정은 최소화하도록 프로그램을 작성해야한는 객체지향 설계 원칙을 말한다. 
