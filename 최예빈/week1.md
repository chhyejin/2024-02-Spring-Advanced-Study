> TLDR;
관심사를 분명하게 정의하고, 오브젝트가 관심 갖는 내용을 작게 쪼갠다. 

## 1.1 초난감 DAO

> DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다. 

### 이 장에서 가져야할 의문점 

1. 왜 코드를 하나의 DAO로 작성했을 때 문제가 발생할까?
1. 잘 동작하는 코들를 굳이 수정하고 개선해야 하는 이유는? 
1. 개선점이 현재와 미래에 가져오는 이점은?
1. 이러한 개선 작업이 객체지향 설계 원칙과 무슨 연관이 있는지? 
1. 이러한 개선 작업이 스프링에서는 어떤 차이를 가져오는지? 


## 1.2 DAO의 분리

### 관심사의 분리

> 현재 DAO가 너무나 많은 것에 관심을 갖고 있다.

1. DB 연결을 위한 커넥션 생성
1. 사용자 등록 쿼리 작업
1. 공유 리소스 반납

> 코드의 재사용성을 높이고 확장성을 제공하자. 

- 일단 중복 코드를 메소드로 추출
- 이후 클래스로 분리하여 객체 생성 및 작업 흐름을 분리


### 템플릿 메소드 패턴

상속을 통해 슈퍼클래스의 기능을 확장하는 방법. 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의한다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 한다. 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다. 

### 팩토리 메소드 패턴 

템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장한다. 구조도 비슷하다. 슈퍼클래스 코드에서 인터페이스 타입 오브젝트를 리턴하는 메소드를 만든다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

## 1.3 DAO의 확장

### 인터페이스의 도입

- UserDao가 여전히 DB 커넥션을 구체적으로 알고 있어야 한다는 문제. 
- 추상화란 공통적인 성격을 뽑아내 따로 분리해내는 작업이다. 자바에서는 추상화를 제공하는 도구는 인터페이스다.
- 인터페이스는 구현에 대한 구체적인 정보를 모두 감춘다. 이를 통해 접근하면 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.

### 관계설정을 인터페이스가 하게 만들자

- UserDao는 구현체가 D인지 N인지 알 필요가 없다.
- UserDao 내부에 있던 관계 맺기에 대한 책임을 외부로 던진다. 이제 관계는 외부에서 주입한다. 
- 이제 UserDao가 SQL 생성 및 실행 작업에만 집중할 수 있게 되었다. 

### 객체지향 설계 원칙: SOLID

```markdown
SRP(Single Responsibility Principle) : 단일 책임 원칙
OCP(Open Close Principle) : 개방 폐쇄 원칙
LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
ISP(Inteface Segregation Principle) : 인터페이스 분리 원칙
DIP(Dependency Inversion Principle) : 의존관계 역전 원칙
```

### 높은 응집도와 낮은 결합도 

> 모듈이란, 패키지는 여러 클래스들의 모음이고, 모듈은 여러 패키지들의 모음을 말합니다.(자바 : 모듈 > 패키지 > 클래스) 하지만 여기서는 모듈 뿐만 아니라 컴포넌트, 패키지, 그리고 클래스를 통틀어 말합니다. 

- 높은 응집도 : 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에 집중되어 있다는 뜻이다. 응집도가 높은 것은 변화가 일어날 때 해당 모듈에서 변화가 적용되는 부분이 크다는 것을 의미한다. 즉, 변경이 일어날 때 모듈의 많은 부분이 바뀌면 응집도가 높다.

- 낮은 결합도 : 결합도란 '하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'라고 설명할 수 있다. 즉, 낮은 결합도란 변경이 생겼을 때 다른 모듈과 객체로 변경의 영향이 전파되지 않는 상태를 뜻한다.


## 1.4 제어의 역전(IoC)

### 팩토리 != 팩토리 메서드 패턴

- 여기서 팩토리는 객체의 생성 방법을 결정하고 오브젝트를 반환하는 것을 의미한다. 

### 제어권 이전을 통한 제어 관계의 역전

- 일반적인 프로그램의 흐름을 보면 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 오브젝트를 생성하고 사용한다. 
- 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는다. 오브젝트는 본인이 사용할 오브젝트를 외부에서 받아서 사용해야 한다. 이전과 다르게 본인이 직접 제어 권한을 가지지 않고 다른 대상에게 위임하기 때문이다. 
- 이런 제어의 역전은 다양한 곳에서 사용되고 있다. 초난감DAO에서 봤던 템플릿 메소드 패턴도 제어의 역전에 속한다. 슈퍼클래스인 UserDao에게 add(), get()을 받아 사용하기 때문이다. 프레임워크도 제어의 역전의 대표 기술이다. 프레임워크는 애플리케이션 코드가 프레임워크에 의해 사용된다. 

## 1.5 스프링의 IoC

### 애플리케이션 컨텍스트

Bean(빈): 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 부르며, 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리킨다.

Bean Factory(빈 팩토리): 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트다.

Applcation Context(애플리케이션 컨텍스트): 빈 팩토리의 확장판. 보통 빈 팩토리와 같은 의미로 사용한다. 빈 팩토리라 말하면 IoC 기본 기능에 초점을 맞춘거고, 애플리케이션 컨텍스트라고 말할 때는 애플리케이션의 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각된다.

### 설정 정보

```java
@Configuration  // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보로 등록된다 
public class DaoFactory {

    @Bean       // 오브젝트 생성을 담당하는 IoC용 메소드라는 표시
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }
    
    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    } 
}
```

### 스프링에서의 오브젝트 팩토리는 뭐가 다를까? 

- 이전에 사용했던 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다. 스프링에서는 이 애플리케이션 컨텍스트를 IoC 컨테이너 혹은 스프링 컨테이너라고 부른다. 또는 빈 팩토리라고도 한다. ApplicationContext는 BeanFactory 인터페이스를 상속해서 일종의 빈 팩토리다. 
- 오브젝트 팩토리와 비교했을 때 장점은 다음과 같다.
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
    - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 스프링 IoC 용어

> 빈(bean) : 스프링이 IoC 방식으로 관리하는 오브젝트 중에서 스프링이 직접 생성과 제어를 담당하는 오브젝트만을 빈으로 본다. 
> 
> 빈 팩토리(bean factory) : IoC를 담당하는 핵심 컨테이너로 빈을 등록하고 생성하고 조회하는 등 관리하는 기능을 담당한다.
>
> 애플리케이션 컨테스트(application context) : 빈 팩토리를 확장한 IoC 컨테이너다. 빈 팩토리가 빈의 생성과 제어의 관점이라면 애플리케이션 컨텍스트는 스프링이 제공하는 지원 기능을 포함해서 이야기한다.
>
> 설정정보/설정 메타정보(configuration metadata) : IoC 컨테이너에 관리되는 애플리케이션 오브젝트의 형상 정보다
>
> 컨테이너(container) 또는 IoC 컨테이너 : IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다.
>
> 스프링 프레임워크 : IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말한다.


## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 싱글톤 레지스트리 

애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리다. 스프링은 기본적으로 내부에서 생성하는 빈 오브젝트를 싱글톤으로 만든다.

### 싱글톤 패턴 

싱글톤으로 만든 이유는 스프링은 대부분 서버 환경에서 사용되기 때문이다. 초당 수십에서 수백 번의 요청이 들어오는 환경에서 요청마다 오브젝트를 만들면 서버가 감당하기 힘들어진다. 그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍 사용해왔다. 서블릿은 가장 기본적인 서비스 오브젝트라고 할 수 있으며, 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들고 공유해 동시에 사용한다. 

### 안티패턴으로 불린다던데? 

싱글톤 패턴의 한계

- private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤은 테스트하기가 힘들다
- 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
- 싱글톤의 사용은 전역 상태를 만들기 때문에 바람직하지 못하다

싱글톤 주의점

- 멀티스레드 환경에서 상태 정보를 갖지 않는 무상태를 유지해야 한다.
- 만약 상태가 읽기 전용으로 사용된다면 문제가 없다.

### 스프링의 싱글톤은 다르다

디자인 패턴의 싱글톤과 비슷한 개념이지만, 구현 방법은 다르다. 이를 우리가 직접 구현할 일은 없으니 원리만 한 번 보고 넘어가면 되겠다. 


## 1.7 의존관계 주입(DI)

### 스프링 DI의 핵심 

DI는 오브젝트 레퍼런스를 외부로부터 주입받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다. 의미를 되새기기 위해 DI는 **'의존관계 주입'**으로 부르자. 

### 의존관계란 무엇인가

> 의존한다는 건 A라는 클라이언트가 기능 구현함에 있어 B를 사용해야 된다는 의미다.

기능 구현에 B를 사용해야 하는데 B에 변경이 일어나면, 이를 가져다 사용하는 A도 변경의 영향을 받게 된다. 이렇게 사용의 관계에 있는 경우 A와 B는 의존관계가 있다 말할 수 있다. 반대로 보면 B는 A에 의존하지 않고, A의 변화에 영향을 안 받는다는 뜻이다.

### 의존관계 주입 조건

- 인터페이스에만 의존하고 있어야 한다
- 런타임 시점의 의존관계는 컨테이너 or 팩토리 같은 제3의 존재가 결정한다.
- 의존관계에 사용될 오브젝트를 외부에서 주입해줌으로써 정해진다.

### 의존관계 주입 방법 

1. 생성자 주입 (DI 방식에 가장 적합)
```java
public UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
}
```
2. 수정자 메소드 주입
```java
public void setConnectionMaker(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
}
```
3. 일반 메소드 주입
```java
public void add(User user, ConnectionMaker connectionMaker) throws ClassNotFoundException, SQLException {
    Connection c = connectionMaker.makeConnection();
...
}
```

### 스프링 하다 == DI 하다 

스프링의 특별함은 99% DI에서 온다. 


## 1.8 XML을 이용한 설정

### XML을 왜 쓰지? 

의존정보를 자바 코드로 정해주고 수정될 때마다 다시 컴파일하는 것이 번거롭다. 다른 방법으로 DI 의존관계 설정 정보를 만들 수 있는데, 바로 XML이다. XML은 단순한 텍스트 파일이라 다루기 쉽고 빌드 작업이 없는 게 장점이다.


## 참고 자료 

- [도서 소스코드](https://github.com/AcornPublishing/toby-spring3-1)
- [XML 설정법](https://johngrib.github.io/wiki/spring-bean-config-xml/)
- [이제 XML보다 Java로 등록 정보 설정을 하는 이유](https://mangkyu.tistory.com/158)